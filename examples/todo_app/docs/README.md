# DuckDBデータベース設計案

**基本的な考え方:**

DuckDBはOLAP (Online Analytical Processing) に強く、大量データの高速集計・分析に適していますが、埋め込み型でPythonなどからのアクセスも容易なため、今回の要件にも十分対応可能です。

Markdownファイルをそのまま保存するのではなく、内容をある程度構造化して保存することで、AIによる効率的な処理を可能にします。また、ファイルパスや更新履歴など、メタデータも重要になります。

**テーブル構成案:**

以下のテーブルを設計します。

1. **`specifications` テーブル (仕様書本体の管理)**
    * Markdownファイルの内容と、そのメタデータを管理します。
    * AIによる参照、更新、作成の主要な対象となります。

2. **`sections` テーブル (仕様書のセクション管理)**
    * `specifications` テーブルの`content`カラムを全文検索するだけでも良いですが、AIが特定のセクションを参照したり、更新したりする際に、構造化されたアクセスパスを提供します。
    * 仕様書を論理的なセクション（例: 目的、機能概要、詳細設計、API定義など）に分割して管理することで、AIの理解度と操作性を向上させます。

3. **`revisions` テーブル (仕様書のバージョン履歴)**
    * 仕様書の変更履歴を追跡し、AIが過去のバージョンを参照したり、変更差分を把握したりするために使用します。
    * DuckDBはGitのようなバージョン管理システムではないため、明示的に変更履歴を記録するテーブルが必要です。

4. **`implementations` テーブル (実装コードとの連携)**
    * 仕様書と関連する実装コードの情報を記録します。AIが仕様書からコードを生成したり、コードから仕様書を更新したりする際の橋渡しとなります。

---

## 1. `specifications` テーブル

* **目的:** Markdown形式の仕様書本体とその基本的なメタデータを管理。
* **カラム:**

    | カラム名            | 型          | 制約                                 | 説明                                                      |
    | :------------------ | :---------- | :----------------------------------- | :-------------------------------------------------------- |
    | `spec_id`           | `UUID`      | `PRIMARY KEY`, `NOT NULL`, `UNIQUE`  | 仕様書の一意なID (UUID推奨)                               |
    | `file_path`         | `VARCHAR`   | `NOT NULL`, `UNIQUE`                 | ローカルでのMarkdownファイルのパス（相対パスまたは絶対パス） |
    | `file_name`         | `VARCHAR`   | `NOT NULL`                           | Markdownファイル名 (例: `feature_x_spec.md`)             |
    | `title`             | `VARCHAR`   | `NOT NULL`                           | 仕様書のタイトル (MarkdownのH1見出しなどから抽出)         |
    | `content`           | `VARCHAR`   | `NOT NULL`                           | Markdownファイルの内容全体                                |
    | `current_revision_id` | `UUID`      | `FOREIGN KEY` (to `revisions.revision_id`) | 現在アクティブなリビジョンのID                            |
    | `status`            | `VARCHAR`   | (`Draft`, `Under Review`, `Approved`, `Deprecated`) | 仕様書の現在のステータス                                  |
    | `created_at`        | `TIMESTAMP` | `NOT NULL`                           | レコードが作成された日時                                  |
    | `updated_at`        | `TIMESTAMP` | `NOT NULL`                           | レコードが最後に更新された日時                            |

* **インデックス:** `file_path` にユニークインデックス、`title` にインデックス。
* **考慮事項:**
  * `content` カラムは、AIが参照するMarkdownの全文を格納します。
  * `title` は、AIが仕様書を識別しやすくするために、Markdown内の最初のH1見出しなどから自動抽出することが望ましいです。
  * `current_revision_id` により、常に最新の仕様書内容を参照できます。

---

## 2. `sections` テーブル

* **目的:** 仕様書内の論理的なセクションを管理し、AIが特定のセクションに焦点を当てて操作できるようにする。
* **カラム:**

    | カラム名          | 型          | 制約                                     | 説明                                          |
    | :---------------- | :---------- | :--------------------------------------- | :-------------------------------------------- |
    | `section_id`      | `UUID`      | `PRIMARY KEY`, `NOT NULL`, `UNIQUE`      | セクションの一意なID                          |
    | `spec_id`         | `UUID`      | `NOT NULL`, `FOREIGN KEY` (to `specifications.spec_id`) | 所属する仕様書のID                            |
    | `parent_section_id` | `UUID`      | `NULLABLE`, `FOREIGN KEY` (to `sections.section_id`) | 親セクションのID (階層構造用)                 |
    | `heading_level`   | `INTEGER`   | `NOT NULL`                               | Markdownの見出しレベル (例: 1 for `#`, 2 for `##`) |
    | `heading_text`    | `VARCHAR`   | `NOT NULL`                               | セクションの見出しテキスト                    |
    | `content`         | `VARCHAR`   | `NOT NULL`                               | セクションのMarkdown内容                      |
    | `start_line`      | `INTEGER`   | `NOT NULL`                               | 元ファイルでのセクション開始行番号            |
    | `end_line`        | `INTEGER`   | `NOT NULL`                               | 元ファイルでのセクション終了行番号            |
    | `order_in_spec`   | `INTEGER`   | `NOT NULL`                               | 仕様書内でのセクションの順序                  |

* **インデックス:** `spec_id` と `order_in_spec` の複合インデックス。
* **考慮事項:**
  * アプリケーション側でMarkdownパーサー（例: Pythonの`markdown-it-py`など）を使用して、Markdownファイルをセクションに分割し、このテーブルに格納します。
  * AIは「機能概要セクションを更新して」や「API定義セクションのサンプルコードを確認して」といった指示に対して、このテーブルの情報を活用できます。
  * 階層構造を表現するために `parent_section_id` を持ちますが、必要がなければフラットな構造でも構いません。

---

## 3. `revisions` テーブル

* **目的:** `specifications` テーブルの `content` カラムに対する変更履歴を管理する。
* **カラム:**

    | カラム名            | 型          | 制約                                 | 説明                                  |
    | :------------------ | :---------- | :----------------------------------- | :------------------------------------ |
    | `revision_id`       | `UUID`      | `PRIMARY KEY`, `NOT NULL`, `UNIQUE`  | リビジョンの一意なID                  |
    | `spec_id`           | `UUID`      | `NOT NULL`, `FOREIGN KEY` (to `specifications.spec_id`) | 関連する仕様書のID                    |
    | `content_snapshot`  | `VARCHAR`   | `NOT NULL`                           | そのリビジョンでの仕様書内容の完全なスナップショット |
    | `change_summary`    | `VARCHAR`   |                                      | このリビジョンでの変更点の要約        |
    | `changed_by`        | `VARCHAR`   |                                      | 変更を行ったユーザーまたはAIのエージェント名 |
    | `created_at`        | `TIMESTAMP` | `NOT NULL`                           | リビジョンが作成された日時            |

* **インデックス:** `spec_id` と `created_at` の複合インデックス。
* **考慮事項:**
  * 仕様書が更新されるたびに、このテーブルに新しいリビジョンが追加されます。
  * `content_snapshot` はその時点での仕様書全体のコピーを保存します。これにより、DuckDBの強みである高速なデータ取得を活かせます。差分ではなく完全なスナップショットを保存することで、DuckDBではよりシンプルに扱えます。
  * AIは過去の仕様書を参照したり、変更差分を比較したりする際にこのテーブルを利用します。

---

## 4. `implementations` テーブル

* **目的:** 仕様書と関連する実装コードの情報を管理する。
* **カラム:**

    | カラム名                  | 型          | 制約                                 | 説明                                          |
    | :------------------------ | :---------- | :----------------------------------- | :-------------------------------------------- |
    | `implementation_id`       | `UUID`      | `PRIMARY KEY`, `NOT NULL`, `UNIQUE`  | 実装レコードの一意なID                        |
    | `spec_id`                 | `UUID`      | `NOT NULL`, `FOREIGN KEY` (to `specifications.spec_id`) | 関連する仕様書のID                            |
    | `related_section_id`      | `UUID`      | `NULLABLE`, `FOREIGN KEY` (to `sections.section_id`) | 関連する仕様書のセクションID（オプション）    |
    | `code_path`               | `VARCHAR`   | `NOT NULL`                           | ソースコードファイルへのパス                  |
    | `function_name`           | `VARCHAR`   | `NULLABLE`                           | 関連する関数名やクラス名（AIが生成する可能性） |
    | `code_snippet`            | `VARCHAR`   | `NULLABLE`                           | 関連するコードスニペット（部分的な保存）      |
    | `description`             | `VARCHAR`   | `NULLABLE`                           | 実装内容の簡単な説明                          |
    | `last_synced_at`          | `TIMESTAMP` | `NOT NULL`                           | 最後にコードと同期された日時                  |

* **インデックス:** `spec_id` にインデックス。
* **考慮事項:**
  * AIが仕様書からコードを生成した場合、このテーブルにその情報が記録されます。
  * AIが既存コードから仕様書を生成・更新する場合、既存コードの情報をこのテーブルに記録し、そこから仕様書を紐付けます。
  * `code_snippet` は、AIがコードを生成する際に特定のコードブロックを再利用したり、参照したりするのに役立ちます。ただし、コード全体を保存するのではなく、関連性の高い部分を保存するようにします。

---

## AIとDBの連携フロー例 (Cursor Chat欄での操作)

1. **AIへの指示: 「Feature Xの仕様書を確認して」**
    * AIは`specifications`テーブルから`title`が「Feature X」のレコードを検索し、`content`カラムを読み込み、概要をチャットで提示。
    * 必要であれば、`sections`テーブルからセクション一覧を取得し、「どのセクションについて知りたいか」を尋ねる。

2. **AIへの指示: 「ログイン機能の仕様書を更新して、パスワードポリシーを強化する」**
    * AIは`specifications`テーブルから「ログイン機能」の仕様書を特定。
    * `sections`テーブルを参照し、「パスワードポリシー」関連のセクションがあればその`content`を読み込む。
    * ユーザーの指示に基づいてMarkdown内容を修正した新しい`content`を生成。
    * **トランザクション:**
        * `revisions`テーブルに旧`content`のスナップショットと変更概要を記録。
        * `specifications`テーブルの`content`と`updated_at`を更新し、`current_revision_id`を新しいリビジョンIDに更新。
        * 必要であれば、`sections`テーブルも更新（セクションの追加、削除、内容変更）。
        * ローカルのMarkdownファイルも更新（アプリケーション側でDuckDBから読み出してファイルに書き戻す）。

3. **AIへの指示: 「認証APIの仕様書から、Pythonでユーザー登録のAPIクライアントコードを生成して」**
    * AIは`specifications`テーブルから「認証API」の仕様書を特定。
    * `sections`テーブルからAPI定義関連のセクション（例: `/api/register` エンドポイントの説明）を読み込む。
    * その情報に基づいてPythonコードを生成。
    * 生成されたコードはローカルファイルに保存。
    * **DBへの記録:**
        * `implementations`テーブルに、生成されたコードのパス、関連する仕様書ID、関数名、必要であればスニペットを記録。
        * これにより、AIが後で「このコードはどの仕様書から生成されたか」を追跡できる。

4. **AIへの指示: 「最近コミットしたAPIの変更から、関連する仕様書を更新して」**
    * ユーザーがCursorのGit連携機能などでコードの変更をAIに提示。
    * AIは変更されたコードを解析。
    * `implementations`テーブルを検索し、このコードがどの仕様書（`spec_id`）に関連しているかを特定。
    * 関連する`specifications`テーブルの`content`を読み込み、コードの変更内容に基づいて仕様書を更新する提案を行う。
    * ユーザーの承認後、上記2の「仕様書更新」と同様のDB更新とファイル更新を行う。

---

## DuckDB利用のメリット

* **組み込み型:** Pythonアプリケーションから直接アクセスでき、デプロイが非常にシンプルです。
* **高速なOLAPクエリ:** 大量の仕様書やリビジョン、セクションデータに対して、高速な検索や集計が可能です。
* **ファイルベース:** 単一ファイルとして保存されるため、バックアップや移動が容易です。
* **柔軟なスキーマ:** スキーマ変更が必要になった場合でも、比較的柔軟に対応できます。
* **Markdownコンテンツの管理:** `VARCHAR`型で大量のテキストを効率的に保存できます。

## 運用上の考慮事項

* **DuckDBファイルの一元管理:** どこに`.duckdb`ファイルを保存するか決定し、バージョン管理に含めるか検討します。
* **ファイル同期メカニズム:** DuckDB内のデータとローカルのMarkdownファイルとの同期は、アプリケーションロジックで実装する必要があります。
  * ファイルシステムの変更監視（inotifyなど）を使ってリアルタイムに同期するか、定期的にスキャンして差分を検出するか。
  * AIがDuckDBの`content`を更新した場合、ローカルファイルに書き戻す処理を必ず行う。
* **Markdownパーサーの頑健性:** `sections`テーブルにデータを挿入する際に、Markdownファイルを正確にパースし、見出しレベルやセクション内容を抽出するロジックが必要です。不完全なMarkdownに対するエラーハンドリングも考慮します。
* **トランザクション管理:** 仕様書の更新は、`specifications`、`revisions`、`sections`の複数テーブルにわたる変更となるため、一貫性を保つためにトランザクションを適切に管理する必要があります。
* **AIのエージェント管理:** AIがDBにアクセスし、データを操作するための適切な認証・認可メカニズムを考慮します（DuckDB自体にはユーザー管理機能が限定的であるため、アプリケーション側で実装）。
* **パフォーマンスモニタリング:** 大量のMarkdownファイルやリビジョンが追加された場合のDuckDBのパフォーマンスを監視し、必要に応じてインデックスの調整やデータ構造の最適化を検討します。

この設計案は、AIが仕様書とコードの間をシームレスに行き来し、メンテナンスと開発を加速させる基盤となるでしょう。
